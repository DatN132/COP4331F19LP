    In Deflate, LZ77 and Huffman are both modified to be more efficient with regard to longer, more complex strings.
    
    For LZ77, the encoder no longer encodes no-matched characters. So, instead of <0,0,A>, it is now only simply encoded as A. This change was made so that the encoder does not have to waste space to encode 0s. Once the encoder detects that there are no numbers leading a letter, it will understand that the match distance and match string length are both 0s.
    
    As for Huffman coding, the Huffman binary tree will now have its shortest branch to the left and its longest branch to the right. Previously, the order of the branches did not matter. For characters with the same number of repetitions, their orders will follow their original order inside of the ASCII table. Previously, no such order was enforced.
    
    For the demonstration of Deflate, the very same string from LZ77's demo and Huffman's demo was used for consistency's sake. As a quick reminder, the original, uncompressed string has 26 ASCII characters, that is 208 bits in length. After running through the two stages of Deflate, the string is compressed into a string of 113 bits in length. This is a 46% reduction in length. Although we were able to save some space, the Deflate compression, for this example, did not work as well as the Huffman coding by itself. The disparity is not because the compression itself is bad, it is just that this type of data (i.e. short strings), doesn't work too well with Deflate. It must be noted that Deflate is optimized for large data streams, so the larger the data file, the better it will be able to work its magic.